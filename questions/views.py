from django.shortcuts import render, redirect
from .models import QuestionGroup, Question, Contest, Submission
from django.http import HttpResponse, JsonResponse
from io import BytesIO
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas

from django.contrib.auth.decorators import login_required
from icecream import ic
@login_required
def questions_groups(request, group_id):
    questions = Question.objects.filter(question_group=group_id)
    # need languages only those that are in the questions
    language = []
    for q in questions:
        if q.language not in language:
            language.append(q.language)

    submissions = Submission.objects.filter(user=request.user, question__question_group=group_id)
    user = request.user
    contest = Contest.objects.filter(user=user, question_group=group_id).first()
    context = {
        'questions': questions.order_by('id'),
        'languages': language,
        "group": QuestionGroup.objects.get(id=group_id),
        "user": user,
        "submissions": submissions,
        "contest": contest
    }
    return render(request, 'questions_groups.html', context)
    
@login_required
def question(request, question_id):
    question = Question.objects.get(id=question_id)
    user = request.user
    contest = Contest.objects.filter(user=user, question_group=question.question_group).first()

    try:
        submission = Submission.objects.filter(user=user, question=question).first()
        ic(submission.id)
    except:
        submission = None
    context = {
        'question': question,
        'user': user,
        'contest': contest,
        'submission':submission
    }
    return render(request, 'question.html', context)

from django.shortcuts import HttpResponse, get_object_or_404
from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Preformatted
from reportlab.lib.styles import getSampleStyleSheet
from io import BytesIO
from datetime import datetime
from .models import Question, Submission, QuestionGroup
from datetime import datetime, timedelta

@login_required
def generate_report(request, group_id):
    # Check if the user is authenticated
    if not request.user.is_authenticated:
        return HttpResponse("Unauthorized", status=401)

    # Ensure the group exists
    group = get_object_or_404(QuestionGroup, id=group_id)

    # Create a BytesIO buffer for the PDF
    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=letter)

    # Set up styles
    styles = getSampleStyleSheet()
    title_style = styles['Heading1']
    metadata_style = styles['BodyText']
    section_title_style = styles['Heading2']
    question_style = styles['BodyText']
    submission_style = styles['Italic']
    code_style = styles['Code']
    status_style = styles['BodyText']

    # Title for the PDF
    elements = [Paragraph(f"Questions Report: {group.name}", title_style), Spacer(1, 12)]

    # Add metadata
    username = request.user.username
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    total_questions = Question.objects.filter(question_group=group).count()
    submitted_questions = Submission.objects.filter(question__question_group=group, user=request.user).values_list('question', flat=True).distinct().count()
    passed_tests = Submission.objects.filter(
        question__question_group=group, user=request.user, test_status=True
    ).count()

    elements.append(Paragraph(f"Generated by: {username}", metadata_style))
    elements.append(Paragraph(f"Timestamp: {timestamp}", metadata_style))
    elements.append(Paragraph(f"Questions Submitted: {submitted_questions} out of {total_questions}", metadata_style))
    elements.append(Paragraph(f"Tests Passed: {passed_tests} out of {total_questions}", metadata_style))
    elements.append(Spacer(1, 24))

    # Fetch data: Questions grouped by language, filtered by group_id
    languages = Question.objects.filter(question_group=group).values_list('language__name', flat=True).distinct()

    for language in languages:
        elements.append(Paragraph(f"Language: {language}", section_title_style))
        elements.append(Spacer(1, 12))

        # Fetch questions for the current language and group
        questions = Question.objects.filter(language__name=language, question_group=group)
        for question in questions:
            # Add question title
            elements.append(Paragraph(f"Question: {question.title}", question_style))
            elements.append(Spacer(1, 6))

            # Add formatted question details
            elements.append(Paragraph(question.question, question_style))
            elements.append(Spacer(1, 12))

            # Fetch submissions for the current question by the logged-in user
            submissions = Submission.objects.filter(question=question, user=request.user)
            if submissions.exists():
                for submission in submissions:
                    elements.append(Paragraph("Your Submission:", submission_style))
                    elements.append(Spacer(1, 6))
                    elements.append(Preformatted(submission.code, code_style))
                    elements.append(Spacer(1, 6))
                    # Add test_status (Pass/Fail)
                    test_status = "Pass" if submission.test_status else "Fail"
                    elements.append(Paragraph(f"Test Status: {test_status}", status_style))
                    elements.append(Spacer(1, 12))
            else:
                elements.append(Paragraph("No submission found.", submission_style))
                elements.append(Spacer(1, 12))

        # Add space between languages
        elements.append(Spacer(1, 24))

    # Build the PDF
    doc.build(elements)
    buffer.seek(0)
    return HttpResponse(buffer, content_type="application/pdf")

@login_required
def add_user_to_contest(request, group_id):
    # Ensure the user is authenticated
    if not request.user.is_authenticated:
        return HttpResponse("Unauthorized", status=401)

    # Ensure the group exists
    group = get_object_or_404(QuestionGroup, id=group_id)

    # Create a new contest instance
    contest, created = Contest.objects.get_or_create(
        user=request.user,
        question_group=group,
        defaults={
            'start_time': datetime.now(),
            'duration': timedelta(minutes=120)
        }
    )
    if created:
        contest.save()
    return redirect('questions:q_group', group_id=group_id)

@login_required
def deduct_time(request, contest_id, time):
    # Ensure the user is authenticated
    if not request.user.is_authenticated:
        return HttpResponse("Unauthorized", status=401)

    # Ensure the contest exists
    contest = get_object_or_404(Contest, id=contest_id)

    # Deduct 5 minutes from the contest duration
    contest.duration -= timedelta(minutes=time)
    contest.save()
    return JsonResponse({'status': 'success', 'new_duration': contest.duration.total_seconds()})

@login_required
def increase_time(request, contest_id, time):
    # Ensure the user is authenticated
    if not request.user.is_authenticated:
        return HttpResponse("Unauthorized", status=401)

    # Ensure the contest exists
    contest = get_object_or_404(Contest, id=contest_id)

    # Increase the contest duration by the specified time
    contest.duration += timedelta(minutes=time)
    contest.save()
    return JsonResponse({'status': 'success', 'new_duration': contest.duration.total_seconds()})